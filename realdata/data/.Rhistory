Z[, variable.of.interest] <- voi
}
if(!is.numeric(voi)) {
voi.name <- paste0(variable.of.interest, levels(as.factor(voi))[-1])
} else {
voi.name <- variable.of.interest
}
if(is.null(rownames(otu.tab))) {
taxa.name <- (1 : nrow(otu.tab))[keep.tax]
} else {
taxa.name <- rownames(otu.tab)[keep.tax]
}
if(is.null(rownames(meta))) {
samp.name <- (1 : nrow(meta))[keep.sam]
} else {
samp.name <- rownames(meta)[keep.sam]
}
## handling zeros
if(any(Y == 0)) {
use.impute <- FALSE
if(corr.cut == 0) {
} else if(corr.cut == 1) {
use.impute <- TRUE
} else {
N <- colSums(Y)
err <- try({
oldw <- getOption('warn')
options(warn = -1)
if(is.numeric(voi)) {
corr.pval <- cor.test(voi, N, alternative = 'two.sided', method = 'spearman')$p.value
} else {
tmp <- unique(voi)
if(length(tmp) == 2) {
corr.pval <- wilcox.test(N[voi == tmp[1]], N[voi == tmp[2]])$p.value
} else {
corr.pval <- kruskal.test(N ~ voi)$p.value
}
}
options(warn = oldw)
if(corr.pval <= corr.cut) {
use.impute <- TRUE
if(trace) cat(paste0('P-value of the association between the variable of interest and sequencing depth: ', corr.pval, '. ', 'Use impution for zeros.\n'))
} else {
if(trace) cat(paste0('P-value of the association between the variable of interest and sequencing depth: ', corr.pval, '. ', 'Use pseudo-count for zeros.\n'))
}
}, silent = TRUE)
if(class(err) == 'try-error') {
if (trace) cat('No p-value of the association between the variable of interest and sequencing depth returned. Use pseudo-count for zeros.\n')
}
}
if(use.impute) {
N <- colSums(Y)
N.mat <- matrix(rep(N, m), nrow = m, byrow = TRUE)
N.mat[Y > 0] <- 0
tmp <- N[max.col(N.mat)]
Y <- Y + N.mat / tmp
} else {
Y <- Y + pseudo.cnt
}
}
## CLR transformation
logY <- log2(Y)
W <- t(logY) - colMeans(logY)
## linear regression
oldw <- getOption('warn')
options(warn = -1)
if(!random.effect) {
suppressMessages(fit <- lm(as.formula(paste0('W', formula)), Z))
res <- do.call(rbind, coef(summary(fit)))
df <- rep(n - ncol(model.matrix(fit)), m)
} else {
fun <- function(i) {
w <- W[, i]
fit <- lmerTest::lmer(as.formula(paste0('w', formula)), Z)
coef(summary(fit))
}
if(n.cores > 1) {
res <- mclapply(c(1 : m), function(i) fun(i), mc.cores = n.cores)
} else {
suppressMessages(res <- foreach(i = 1 : m) %do% fun(i))
}
res <- do.call(rbind, res)
}
options(warn = oldw)
res.intc <- res[which(rownames(res) == '(Intercept)'), ]
rownames(res.intc) <- NULL
baseMean <- 2 ^ res.intc[, 1]
baseMean <- baseMean / sum(baseMean) * 1e6
output.fun <- function(x) {
res.voi <- res[which(rownames(res) == x), ]
rownames(res.voi) <- NULL
if(random.effect) {
df <- res.voi[, 3]
}
log2FoldChange <- res.voi[, 1]
lfcSE <- res.voi[, 2]
oldw <- getOption('warn')
options(warn = -1)
suppressMessages(bias <- mlv(sqrt(n) * log2FoldChange,
method = 'meanshift', kernel = 'gaussian') / sqrt(n))
options(warn = oldw)
log2FoldChange <- log2FoldChange - bias
stat <- log2FoldChange / lfcSE
pvalue <- 2 * pt(-abs(stat), df)
padj <- p.adjust(pvalue, method = p.adj.method)
reject <- padj <= alpha
output <- cbind.data.frame(baseMean, log2FoldChange, lfcSE, stat, pvalue, padj, reject, df)
rownames(output) <- taxa.name
return(list(bias = bias, output = output))
}
voi.n <- length(voi.name)
bias <- rep(NA, voi.n)
output <- list()
for(i in 1 : voi.n) {
tmp <- output.fun(voi.name[i])
output[[i]] <- tmp[[2]]
bias[i] <- tmp[[1]]
}
names(output) <- voi.name
rownames(Y) <- taxa.name
colnames(Y) <- samp.name
rownames(Z) <- samp.name
return(list(bias = bias, output = output, otu.tab.use = Y, meta.use = Z,
variable.of.interest = variable.of.interest))
}
load("smoker_qiita_full.RData")
winsor.fun <- function(Y, quan) {
N <- colSums(Y)
P <- t(t(Y) / N)
cut <- apply(P, 1, quantile, quan)
Cut <- matrix(rep(cut, ncol(Y)), nrow(Y))
ind <- P > Cut
P[ind] <- Cut[ind]
Y <- round(t(t(P) * N))
return(Y)
}
linda <- function(otu.tab, meta, formula, variable.of.interest = NULL,
level.ref = NULL, corr.cut = 0.1, pseudo.cnt = 0.5,
p.adj.method = 'BH', alpha = 0.05,
prev.cut = 0, lib.cut = 1, winsor.quan = NULL, n.cores = 1, trace = FALSE) {
if(any(is.na(otu.tab))) {
stop('The OTU table contains NAs! Please remove!\n')
}
allvars <- all.vars(as.formula(formula))
if(is.null(variable.of.interest)) {
variable.of.interest <- allvars[1]
}
Z <- as.data.frame(meta[, allvars])
## preprocessing
keep.sam <- colSums(otu.tab) >= lib.cut & rowSums(is.na(Z)) == 0
Y <- otu.tab[, keep.sam]
Z <- as.data.frame(Z[keep.sam, ])
names(Z) <- allvars
n <- ncol(Y)
keep.tax <- rowSums(Y > 0) / n >= prev.cut
Y <- Y[keep.tax, ]
m <- nrow(Y)
ind <- sapply(1 : ncol(Z), function(i) is.numeric(Z[, i]))
Z[, ind] <- scale(Z[, ind])
if(!is.null(winsor.quan)) {
Y <- winsor.fun(Y, winsor.quan)
}
##
if(grepl('\\(', formula)) {
random.effect <- TRUE
} else {
random.effect <- FALSE
}
voi <- Z[, variable.of.interest]
if(!is.null(level.ref)) {
voi <- relevel(as.factor(voi), level.ref)
Z[, variable.of.interest] <- voi
}
if(!is.numeric(voi)) {
voi.name <- paste0(variable.of.interest, levels(as.factor(voi))[-1])
} else {
voi.name <- variable.of.interest
}
if(is.null(rownames(otu.tab))) {
taxa.name <- (1 : nrow(otu.tab))[keep.tax]
} else {
taxa.name <- rownames(otu.tab)[keep.tax]
}
if(is.null(rownames(meta))) {
samp.name <- (1 : nrow(meta))[keep.sam]
} else {
samp.name <- rownames(meta)[keep.sam]
}
## handling zeros
if(any(Y == 0)) {
use.impute <- FALSE
if(corr.cut == 0) {
} else if(corr.cut == 1) {
use.impute <- TRUE
} else {
N <- colSums(Y)
err <- try({
oldw <- getOption('warn')
options(warn = -1)
if(is.numeric(voi)) {
corr.pval <- cor.test(voi, N, alternative = 'two.sided', method = 'spearman')$p.value
} else {
tmp <- unique(voi)
if(length(tmp) == 2) {
corr.pval <- wilcox.test(N[voi == tmp[1]], N[voi == tmp[2]])$p.value
} else {
corr.pval <- kruskal.test(N ~ voi)$p.value
}
}
options(warn = oldw)
if(corr.pval <= corr.cut) {
use.impute <- TRUE
if(trace) cat(paste0('P-value of the association between the variable of interest and sequencing depth: ', corr.pval, '. ', 'Use impution for zeros.\n'))
} else {
if(trace) cat(paste0('P-value of the association between the variable of interest and sequencing depth: ', corr.pval, '. ', 'Use pseudo-count for zeros.\n'))
}
}, silent = TRUE)
if(class(err) == 'try-error') {
if (trace) cat('No p-value of the association between the variable of interest and sequencing depth returned. Use pseudo-count for zeros.\n')
}
}
if(use.impute) {
N <- colSums(Y)
N.mat <- matrix(rep(N, m), nrow = m, byrow = TRUE)
N.mat[Y > 0] <- 0
tmp <- N[max.col(N.mat)]
Y <- Y + N.mat / tmp
} else {
Y <- Y + pseudo.cnt
}
}
## CLR transformation
logY <- log2(Y)
W <- t(logY) - colMeans(logY)
## linear regression
oldw <- getOption('warn')
options(warn = -1)
if(!random.effect) {
suppressMessages(fit <- lm(as.formula(paste0('W', formula)), Z))
res <- do.call(rbind, coef(summary(fit)))
df <- rep(n - ncol(model.matrix(fit)), m)
} else {
fun <- function(i) {
w <- W[, i]
fit <- lmerTest::lmer(as.formula(paste0('w', formula)), Z)
coef(summary(fit))
}
if(n.cores > 1) {
res <- mclapply(c(1 : m), function(i) fun(i), mc.cores = n.cores)
} else {
suppressMessages(res <- foreach(i = 1 : m) %do% fun(i))
}
res <- do.call(rbind, res)
}
options(warn = oldw)
res.intc <- res[which(rownames(res) == '(Intercept)'), ]
rownames(res.intc) <- NULL
baseMean <- 2 ^ res.intc[, 1]
baseMean <- baseMean / sum(baseMean) * 1e6
output.fun <- function(x) {
res.voi <- res[which(rownames(res) == x), ]
rownames(res.voi) <- NULL
if(random.effect) {
df <- res.voi[, 3]
}
log2FoldChange <- res.voi[, 1]
lfcSE <- res.voi[, 2]
oldw <- getOption('warn')
options(warn = -1)
suppressMessages(bias <- mlv(sqrt(n) * log2FoldChange,
method = 'meanshift', kernel = 'gaussian') / sqrt(n))
options(warn = oldw)
log2FoldChange <- log2FoldChange - bias
stat <- log2FoldChange / lfcSE
pvalue <- 2 * pt(-abs(stat), df)
padj <- p.adjust(pvalue, method = p.adj.method)
reject <- padj <= alpha
output <- cbind.data.frame(baseMean, log2FoldChange, lfcSE, stat, pvalue, padj, reject, df)
rownames(output) <- taxa.name
return(list(bias = bias, output = output))
}
voi.n <- length(voi.name)
bias <- rep(NA, voi.n)
output <- list()
for(i in 1 : voi.n) {
tmp <- output.fun(voi.name[i])
output[[i]] <- tmp[[2]]
bias[i] <- tmp[[1]]
}
names(output) <- voi.name
rownames(Y) <- taxa.name
colnames(Y) <- samp.name
rownames(Z) <- samp.name
return(list(bias = bias, output = output, otu.tab.use = Y, meta.use = Z,
variable.of.interest = variable.of.interest))
}
plot.fun <- function(linda.obj, alpha = 0.05, lfc.cut = 1,
taxa.plot = NULL, legend = FALSE, directory = NULL,
width = 11, height = 8) {
bias <- linda.obj$bias
output <- linda.obj$output
otu.tab <- linda.obj$otu.tab.use
meta <- linda.obj$meta.use
variable.of.interest <- linda.obj$variable.of.interest
taxa <- rownames(otu.tab)
m <- length(taxa)
voi.n <- length(bias)
voi <- meta[, variable.of.interest]
if(!is.numeric(voi)) {
lvs <- levels(as.factor(voi))
title <- paste0(variable.of.interest, ': ', lvs[1], ' v.s. ', lvs[-1])
} else {
title <- variable.of.interest
}
padj.mat <- foreach(i = 1 : voi.n, .combine = 'cbind') %do% {
output[[i]]$padj
}
## effect size plot
if(is.matrix(padj.mat)) {
ind <- which(colSums(padj.mat <= alpha) > 0)
} else if(is.vector(padj.mat)) {
tmp <- which(padj.mat <= alpha)
if(length(tmp) > 0){
ind <- 1
} else {
ind <- integer(0)
}
}
if(length(ind) == 0) {
plot.lfc <- NULL
} else {
if(!is.null(directory)) pdf(paste0(directory, '/plot_lfc.pdf'),
width = width, height = height)
plot.lfc <- list()
j <- 1
for(i in ind) {
output.i <- output[[i]]
bias.i <- bias[i]
lfc <- output.i$log2FoldChange
lfcSE <- output.i$lfcSE
padj <- output.i$padj
ind.rej <- which(padj <= alpha)
n.rej <- length(ind.rej)
taxa.rej <- taxa[ind.rej]
taxa.rej <- factor(taxa.rej, levels = taxa.rej)
data.plot.lfc <- cbind.data.frame(Taxa = rep(taxa.rej, 2),
Log2FoldChange = c(lfc[ind.rej], lfc[ind.rej] + bias.i),
lfcSE = c(lfcSE[ind.rej], rep(NA, n.rej)),
bias = rep(c('Debiased', 'Non-debiased'), each = n.rej))
plot.lfc.i <- ggplot(data.plot.lfc, aes(x = Log2FoldChange, y = Taxa)) +
geom_point(aes(color = bias, shape = bias), size = 3) +
geom_errorbar(aes(xmin = Log2FoldChange - 1.96 * lfcSE,
xmax = Log2FoldChange + 1.96 * lfcSE), width = .2) +
geom_vline(xintercept = 0, color = 'gray', linetype = 'dashed') +
ggtitle(title[i]) +
theme_bw(base_size = 18)
if(legend) {
plot.lfc.i <- plot.lfc.i +
theme(legend.title = element_blank(),
legend.key.width = unit(1, 'cm'), plot.margin = unit(c(1, 1, 1, 1.5), 'cm'))
} else {
plot.lfc.i <- plot.lfc.i +
theme(legend.position = 'none', plot.margin = unit(c(1, 1, 1, 1.5), 'cm'))
}
plot.lfc[[j]] <- plot.lfc.i
j <- j + 1
if(!is.null(directory)) print(plot.lfc.i)
}
if(!is.null(directory)) dev.off()
}
## volcano plot
plot.volcano <- list()
if(!is.null(directory)) pdf(paste0(directory, '/plot_volcano.pdf'),
width = width, height = height)
leg1 <- paste0('padj>', alpha, ' & ', 'lfc<=', lfc.cut)
leg2 <- paste0('padj>', alpha, ' & ', 'lfc>', lfc.cut)
leg3 <- paste0('padj<=', alpha, ' & ', 'lfc<=', lfc.cut)
leg4 <- paste0('padj<=', alpha, ' & ', 'lfc>', lfc.cut)
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1 : n]
}
color <- gg_color_hue(3)
for(i in 1 : voi.n) {
output.i <- output[[i]]
bias.i <- bias[i]
lfc <- output.i$log2FoldChange
padj <- output.i$padj
ind1 <- padj > alpha & abs(lfc) <= lfc.cut
ind2 <- padj > alpha & abs(lfc) > lfc.cut
ind3 <- padj <= alpha & abs(lfc) <= lfc.cut
ind4 <- padj <= alpha & abs(lfc) > lfc.cut
leg <- rep(NA, m)
leg[ind1] = leg1
leg[ind2] = leg2
leg[ind3] = leg3
leg[ind4] = leg4
leg <- factor(leg, levels = c(leg1, leg2, leg3, leg4))
taxa.sig <- rep('', m)
taxa.sig[ind3 | ind4] <- taxa[ind3 | ind4]
data.volcano <- cbind.data.frame(taxa = taxa.sig, Log2FoldChange = lfc,
Log10Padj = -log10(padj), leg = leg)
plot.volcano.i <- ggplot(data.volcano, aes(x = Log2FoldChange, y = Log10Padj)) +
geom_point(aes(color = leg), size = 2) +
geom_text_repel(aes(label = taxa), max.overlaps = Inf) +
scale_colour_manual(values = c('darkgray', color[c(2, 3, 1)])) +
geom_hline(aes(yintercept = -log10(alpha)), color = 'gray', linetype = 'dashed') +
geom_vline(aes(xintercept = -lfc.cut), color = 'gray', linetype = 'dashed') +
geom_vline(aes(xintercept = lfc.cut), color = 'gray', linetype = 'dashed') +
ylab('-Log10Padj') +
ggtitle(title[i]) +
theme_bw(base_size = 18)
if(legend) {
plot.volcano.i <- plot.volcano.i +
theme(legend.title = element_blank(),
legend.key.width = unit(1, 'cm'), plot.margin = unit(c(1, 1, 1, 1.5), 'cm'))
} else {
plot.volcano.i <- plot.volcano.i +
theme(legend.position = 'none', plot.margin = unit(c(1, 1, 1, 1.5), 'cm'))
}
plot.volcano[[i]] <- plot.volcano.i
if(!is.null(directory)) print(plot.volcano.i)
}
if(!is.null(directory)) dev.off()
## boxplot
plot.taxa.fun <- function(x, y, ylab) {
data <- data.frame(x = x, y =y)
plot1 <- ggplot(data, aes(x = x, y = y)) +
geom_boxplot(aes(color = x)) +
geom_jitter(aes(color = x), position = position_jitter(0.2), size = 2) +
xlab(variable.of.interest) +
ylab(ylab) +
theme_bw(base_size = 18) +
theme(legend.position = 'none', plot.margin = unit(c(1, 1, 1, 1.5), 'cm'))
return(plot1)
}
if(is.numeric(voi)) {
plot.taxa <- NULL
} else {
if(is.matrix(padj.mat)) {
ind <- which(rowSums(padj.mat <= alpha) > 0)
} else if(is.vector(padj.mat)) {
ind <- which(padj.mat <= alpha)
}
if(length(ind) == 0 & is.null(taxa.plot)) {
plot.taxa <- NULL
} else {
if(is.null(taxa.plot)) taxa.plot <- taxa[ind]
N1 <- colSums(otu.tab)
logP1 <- log(t(t(otu.tab) / N1))
plot.taxa <- list()
for(j in 1 : length(taxa.plot)) {
if(!is.null(directory)) pdf(paste0(directory, '/plot_taxa_', taxa.plot[j], '.pdf'),
width = width, height = height)
indy <- which(taxa == taxa.plot[j])
plot.taxa.j <- list()
for(i in 1 : voi.n) {
output.i <- output[[i]]
bias.i <- bias[i]
lfc <- output.i$log2FoldChange
pvalue <- output.i$pvalue
padj <- output.i$padj
large.p <- sort(order(pvalue)[floor(m / 2) : m])
small.lfc <- large.p[sort(order(abs(lfc[large.p]))[1 : floor(m / 4)])]
N2 <- colSums(otu.tab[small.lfc, ])
logP2 <- log(t(t(otu.tab) / N2))
indx <- which(voi %in% lvs[c(1, i + 1)])
x <- voi[indx]
plot.taxa1 <- plot.taxa.fun(x, logP1[indy, indx], 'Log Proportion')
plot.taxa2 <- plot.taxa.fun(x, logP2[indy, indx], 'LR-MNDP')
header <- ggdraw() +
draw_label(paste0('Taxa: ', taxa.plot[j], ' ', 'LFC: ', round(lfc[indy], 3),
' ', 'Padj: ', round(padj[indy], 3)), fontface = 'bold', size = 25)
plot.taxa12 <- plot_grid(plot.taxa1, plot.taxa2, nrow = 1, labels = '')
plot.taxa12 <- plot_grid(header, plot.taxa12, ncol = 1, rel_heights = c(0.1, 1))
plot.taxa.j[[i]] <- plot.taxa12
if(!is.null(directory)) print(plot.taxa12)
}
plot.taxa[[j]] <- plot.taxa.j
if(!is.null(directory)) dev.off()
}
names(plot.taxa) <- taxa.plot
}
}
return(list(plot.lfc = plot.lfc, plot.volcano = plot.volcano, plot.taxa = plot.taxa))
}
library(modeest)
library(foreach)
library(lmerTest)
library(parallel)
library(ggplot2)
library(ggrepel)
library(cowplot)
ind <- smokers$meta$AIRWAYSITE == 'Throat'
otu.tab <- as.data.frame(smokers$otu[, ind])
meta <- cbind.data.frame(Smoke = factor(smokers$meta$SMOKER[ind]),
Sex = factor(smokers$meta$SEX[ind]),
Site = factor(smokers$meta$SIDEOFBODY[ind]),
SubjectID = factor(smokers$meta$HOST_SUBJECT_ID[ind]))
linda.obj <- linda(otu.tab, meta, formula = '~Smoke+Sex+(1|SubjectID)', alpha = 0.1,
prev.cut = 0.1, lib.cut = 1000, winsor.quan = 0.97)
rej <- rownames(linda.obj$output[[1]])[which(linda.obj$output[[1]]$reject)]
nrej <- rownames(linda.obj$output[[1]])[-which(linda.obj$output[[1]]$reject)]
taxa.plot = c(rej[1], nrej[1])
aa=plot.fun(linda.obj, alpha = 0.1, lfc.cut = 1,
taxa.plot = taxa.plot, legend = TRUE, directory = NULL, width = 11, height = 8)
aa$plot.lfc
names(smokers)
dim(smokers$genus)
dim(smokers$family)
load("EmilyIBD.RData")
ls()
